# foo!
"foo"
  "test"
  [
    1 2 3
    1 2 3 # bar!
    1 2 3
  ]
def


# Basic
  
"noop"
  ""
  [  ]
def

 #does nothing.
  
"id"
  ""
  [ [] dip ]
def

 # No-op, but fails if stack is empty.

# Stack manipulation
"swapd"
  ""
  [ [swap] dip ]
def

"swap2"
  ""
  [ swap swapd ]
def

"popd"
  ""
  [ [pop] dip ]
def

"pop2"
  ""
  [ pop pop ]
def

"pop3"
  ""
  [ pop pop pop pop ]
def

"pop4"
  ""
  [ pop pop pop pop ]
def

"dupd"
  ""
  [ [dup] dip ]
def

"dupdd"
  ""
  [ [dupd] dip ]
def

"get2"
  ""
  [ dupd swap ]
def

"get3"
  ""
  [ [get2] dip swap ]
def

"get4"
  ""
  [ [get3] dip swap ]
def

"dup2"
  ""
  [ get2 get2 ]
def

"dup3"
  ""
  [ get3 get3 get3 ]
def

"dup4"
  ""
  [ get4 get4 get4 get4 ]
def

"flip"
  ""
  [ swapd swap swapd ]
def
 # 1 2 3 -> 3 2 1
"flip4"
  ""
  [ swap [flip] dip swap ]
def
 # 1 2 3 4 -> 4 3 2 1
"flip5"
  ""
  [ swap [flip4] dip swap ]
def
 # 1 2 3 4 5 -> 5 4 3 2 1


# Combinators
"dip2"
  ""
  [ swap [dip] dip ]
def


"i"
  ""
  [ dup dip pop ]
def

"keep_i"
  ""
  [ dup [i] dip ]
def



"b"
  ""
  [ [i] dip i ]
def

"m"
  ""
  [ dup i ]
def

"k"
  ""
  [ [pop] dip i ]
def

"c"
  ""
  [ [swap] dip i ]
def

"w"
  ""
  [ [dup] dip i ]
def


# "reverse"
#   ""
#   [ [] [cons] foldl ]
# def



# Quotations

"reverse_cons"
  ""
  [ swap cons ]
def

"reverse_uncons"
  ""
  [ uncons swap ]
def

"unconsd"
  ""
  [ [uncons] dip ]
def

"lift"
  ""
  [ [] reverse_cons ]
def

"liftd"
  ""
  [ [lift] dip ]
def

"lift2"
  ""
  [ [] swapd reverse_cons reverse_cons ]
def

"unlift"
  ""
  [ uncons popd ]
def

"unlift2"
  ""
  [ uncons [uncons popd] dip ]
def


"papply1"
  "This is a very simple implementation akin to papply, but it only works with a single function argument.
  Its advantage is that we don't need recursion, which means that we can use papply1 _inside_ the definition of the y-combinator.

  4 [inc] papply1 ==> [4 inc]
  "

  [ inspect_stack liftd unlift cons ]
def


"partial_y"
  "
  Does most of the work for the y-combinator,
  but does not run the created self-referencing quotation yet.

  Can be used to create generators (?)
  "
  [
    [dup papply1] swap lift2 [b] unlift cons
  ]
def


# y
"y"
  "The y-combinator. Executes a quotation with itself wrapped in the y-combinator as the topmost element on the stack.
  This means that the quotation can call itself recursively by using `i` again inside itself.

  The y-combinator is very useful to build recursive function definitions.
  "
  [ partial_y dup i ]
def



"backwards_append"
  "
  Uses the y-combinator to append a list in reverse order to another list (which is still in original order).
  "
  [
    [[pop2 empty?] # Stop recursion if original list is empty 
      [pop popd] 
      [
        [unconsd reverse_cons] dip  # take one element from the top of the old (bottom-most) list
                                    # And put it at the head of the new list.
        i]                          # And then call recursively.
    ifte] 
  y
  
  ]
def

"reduce"
  ""
  [

  ]
def

# "reverse2"
#   ""
#   [
#      [] # start of the new list being built
#      [
#      [pop2 empty?] # Stop recursion if original list is empty 
#       [pop popd] 
#        [
#         [unconsd reverse_cons] dip  # take one element from the top of the old (bottom-most) list
#                                     # And put it at the head of the new list.
#         i]                          # And then call recursively.
#     ifte] 
#   y
#   ]
# def

"reverse"
  ""
  [ [] backwards_append ]
def

"append"
  ""
  [ reverse backwards_append reverse ]
def

"reverse_append"
  ""
  [ swap append ]
def

"negate"
  ""
  [ [not] papply1 ]
def



"papply"
  "
  Takes the quotation `q` on top, and the value `v` below it.
  Returns a new quotation, which, when evaluated, would first put `v` on the stack, and then run `q`.
  Therefore, it applies the argument `v` to `q`, but does not yet evaluate it. 
  `3 [inc] partial_apply` ==> `[3 inc]`.
  "
  [ [lift] dip append ]
def

"papply2"
  "
  Takes the quotation `q` on top, and the values `v1` and `v2` below it.
  Returns a new quotation, which, when evaluated, would first put `v2`, then `v1` on the stack, and then run `q`.
  Therefore, it applies the arguments `v1` and `v2` to `q`, but does not yet evaluate it. 
  `2 4 [add] partial_apply2` ==> `[2 4 add]`.
  "
  [ papply papply ]
def

"papply3"
  "
  Takes the quotation `q` on top, and the values `v1`, `v2` and `v3` below it.
  Returns a new quotation, which, when evaluated, would first put `v3`, then `v2` and then `v1` on the stack, and then run `q`.
  Therefore, it applies the arguments `v1`, `v2` and `v3` to `q`, but does not yet evaluate it. 
  `2 4 3 [add add] partial_apply3` ==> `[2 4 3 add add]`.
  "
  [ papply papply papply]
def


"simple_generator"
  "
  When invoked with `i`, returns the result of the quotation passed in at the top of the stack,
  while keeping itself as the second element.
  `[3] generator ==> [[dup papply 3] dup papply 3]`
  "
  [
  partial_y dup papply
  ]
def

"generator"
  "
  Create a generator by passing it a starting value and a quotation to execute each time it is invoked.
  The first time the generator is invoked, the starting value is returned.
  The second time, the next value (that is created from executing the quotation with the starting value on the stack).
  The third time, the next value from that computation, etc.

  The value that is found by executing the quotation on the starting value is output,
  and stored in the generator itself, so that when it is invoked again, the output value is used as new
  starting value.

  Example:
  ```
  [3] [inc] generator i # 4
  pop i # 5
  pop i # 6
  ``` 
  "
  [
    [uncons] reverse_append [cons dup papply] append swap cons dup papply
  ]
def


"foldr"
  ""
  [ [reverse] dip2 foldl ]
def

# "reverse_append"
#   ""
#   [ [cons] foldr ]
# def

# "append"
#   ""
#   [ swap reverse_append ]
# def

"dip3"
  ""
  [ swap [dip2] dip ]
def

"dip4"
  ""
  [ swap [dip3] dip ]
def


# Comparison
"falsy?"
  ""
  [ not ]
def

"truthy?"
  ""
  [ falsy? not ]
def

"neq?"
  ""
  [ eq? not ]
def

"zero?"
  ""
  [ 0 eq? ]
def

"one?"
  ""
  [ 1 eq? ]
def

"lt?"
  ""
  [ compare -1 eq? ]
def

"gt?"
  ""
  [ compare 1 eq? ]
def

"gte?"
  ""
  [ compare -1 neq? ]
def

"lte?"
  ""
  [ compare  1 neq? ]
def

"empty?"
  ""
  [ [] compare zero? ]
def

"max"
  ""
  [ [gt?] [pop] [popd] ifte ]
def

"min"
  ""
  [ [lt?] [pop] [popd] ifte ]
def
 
# Arithmetic
"inc"
  ""
  [ 1 add ]
def

"dec"
  ""
  [ 1 sub ]
def

"odd?"
  ""
  [ 1 band truthy? ]
def

"even?"
  ""
  [ odd? not ]
def




# Conditionals
"if"
  ""
  [ [] ifte ]
def

"unless"
  ""
  [ [] swap ifte ]
def






 


"ifeqte"
  ""
  [ [lift [eq?] append] dip2 ifte ]
def

"ifneqte"
  ""
  [ [lift [neq?] append] dip2 ifte ]
def

"ifzte"
  ""
  [ [[zero?]] dip2 ifte ]
def

"ifnzte"
  ""
  [ [[zero? not]] dip2 ifte ]
def

  # (Helper)

"prepend_fold_condition"
  # To be given an 'ifte' with the condition part not yet filled in.
  # Will change `[zero?] [...] [ [A] [B] ifte] prepend_fold_condition`
  # into  `[...] [[zero?] [A] [B] ifte]`
  # TODO: Better name?
  ""
  [ swapd liftd append ]
def

"length"
  ""
  [ 0 [inc] foldl ]
def


"map"
  ""
  [ [] swap [cons] append foldl ]
def

"flatten"
  ""
  [ [] [append] foldl ]
def
 # TODO: Improve
"filter"
  ""
  [ [] [ [cons] [pop] ifte] prepend_fold_condition foldr ]
def

"reject"
  ""
  [ negate filter ]
def

"sum"
  ""
  [ 0 [add] foldl ]
def

#rewrite "product", "1 [mul] foldl"
"list_max"
  ""
  [ uncons [max] foldl ]
def

"list_min"
  ""
  [ uncons [min] foldl ]
def

"list_max_min"
  ""
  [ uncons dup lift2 [dup [unlift2] dip2 swapd max [min] dip lift2] foldl ]
def

"all?"
  ""
  [ true [and] swapd append foldl ]
def

"any?"
  ""
  [ false [or] swapd append foldl ]
def

"contains?"
  ""
  [ lift [eq? or] append false swap foldl ]
def
 # [1 2 3] 1 contains? # TODO: fix append so reverse arguments not necessary in quotation.
"in?"
  ""
  [ swap contains? ]
def
 # 1 [1 2 3] in?

# TODO: take
# TODO: drop
# TODO: take_while
# TODO: drop_while
# TODO: partition

# Boolean
"xor"
  ""
  [ dup2 or [and not] dip and ]
def


# Bitwise
"bxor"
  ""
  [ [dup] dip dup [swap] dip bor [band bnot] dip band ]
def


# Recursion
#rewrite "Z X Y primrec", "Z [[ pop 0 eq?] [pop pop X] [[dup 1 sub] dip dup i Y] ifte] dup i"
# TODO: Optimize with swap2, swap3, cons2, cons3 etc.
# Primitive Recursion takes as (bottom-to-top) input: 
# - value to calculate
# - base case quotation
# - recursive case quotation.
# "primrec"
#   ""
#   [ swap [pop pop] swap cons [pop 0 eq?] swap [[dup 1 sub] dip dup i] [[swap] dip] dip [swap] dip swap append [] swap [swap] dip [[reverse_cons] dip cons] dip cons [ifte] append dup i ]
# def

#rewrite "mul", "[pop pop] [[add] dip] primrec"

# 3 2 mul
# 3 + 3

# Output
"puts"
  ""
  [ print "\n" print ]
def

# Input





# Recursive

"y_factorial"
  "
  Calculates the factorial of the item on top of the stack, using a recursive algorithm.
  `5 factorial` == `5*4*3*2*1` == `120`.
  
  Uses the `y`-combinator internally.
  "
  [
    [
    [pop zero?] # As the y-combinator puts the evaluated function on top, check against the second value. 
      [pop2 1] # Base case: Remove the function and the `0` that is on top, and return `1`.
      [ 
      [dup dec] dip # Duplicate the current number and decrease it by one.
      i             # Then call recusively on that number.
      mul           # After the recursive result is known, multiply the obtained result by our current number.
      ] 
    ifte] 
  y
  ]
def

"primrec"
  "
  input as follows:
  `5 [zero?] [1] [mul] primrec2`
  "
  [
    inspect_stack
    [[pop] reverse_append] dip2         # Changes `... [zero?] [1] [mul]` to `... [pop zero?] [1] [mul]`
    inspect_stack
    [[pop2] reverse_append] dip         # Changes `... [1] [mul]` to `... [pop2 1] [mul]
    inspect_stack
    [[dup dec] dip i] reverse_append  # Changes `... [mul]` to `... [[dup dec] dip i mul]`
    inspect_stack
    [ifte] papply3                      # Combines the different parts to form [[c] [t] [e] ifte]
    inspect_stack
    y
  ]
def

"triangular"
  ""
  [ [zero?] [0] [add] primrec ]
def

"factorial"
  ""
  [ [zero?] [1] [mul] primrec ]
def

"factorial2"
  "
  Calculates the same as `factorial`, but uses rewrite-recursion instead of the y-combinator.

  This function exists to be able to see the difference in speed between the two approaches.
  "
  [
    [zero?] [pop 1] [dup dec factorial2 mul] ifte
  ]
def

"fibonacchi_generator"
  ""
  [
    [1 1]
    [unlift2 
      dup2 add [popd] dip # Add the numbers together to obtain the new number; discard the oldest of the three: 3 5 -> 5 8 
    lift2]
    generator
  ]
def
